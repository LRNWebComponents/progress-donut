<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../materializecss-styles/materializecss-styles.html">
<link rel="import" href="../hax-body-behaviors/hax-body-behaviors.html">
<link rel="import" href="../schema-behaviors/schema-behaviors.html">
<link rel="import" href="../chartist-render/chartist-render.html">
<!--
`progress-donut`
A LRN element

@demo demo/index.html

@microcopy - the mental model for this element
 -
 -

-->

<dom-module id="progress-donut">
  <template>
    <style>
      :host #wrapper {
        position: relative;
        width: 250px;
        padding-bottom: 250px;
      }
      :host[size="xs"] #wrapper {
        width: 150px;
        padding-bottom: 150px;
      }
      :host[size="sm"] #wrapper {
        width: 200px;
        padding-bottom: 200px;
      }
      :host[size="lg"] #wrapper {
        width: 300px;
        padding-bottom: 300px;
      }
      :host[size="xl"] #wrapper {
        width: 400px;
        padding-bottom: 400px;
      }
      :host #wrapper > * {
        position: absolute;
      }
      :host #wrapper #image {
        left: 20%;
        top: 20%;
        width: 60%;
        height: 60%;
        -webkit-clip-path: circle(50% at 50% 50%);
        clip-path: circle(50% at 50% 50%);
      }
      :host #wrapper > chartist-render {
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
      }
    </style>
    <div id="wrapper">
      <img id="image" 
        alt$="[[imageAlt]]" 
        aria-hidden="true"
        hidden$="[[!imageSrc]]"  
        src$="[[imageSrc]]" 
        style$="[[imageStyle]]">
      <chartist-render id="chart" 
        data$="[[data]]"
        chart-desc$="[[desc]]"
        chart-title="[[title]]" 
        class="ct-square" 
        options$="[[options]]" 
        title$="[[title]]"
        type="pie" >
      </chartist-render>
    </div>
  </template>

  <script>
    Polymer({

      is: 'progress-donut',
      behaviors: [HAXBehaviors.PropertiesBehaviors, MaterializeCSSBehaviors.ColorBehaviors, SchemaBehaviors.Schema],
      listeners: {
        'chartist-render-draw': '_onCreated'
      },
      properties: {
        /**
          * An array of completed values
          */
        complete: {
          type: Array,
          value: []
        },
        /**
          * The thickness of the donut from 0-100
          */
        donutThickness: {
          type: Number,
        },
        /**
          * An array of data for the donut chart
          */
        data: {
          type: Array,
          computed: '_getData(complete)'
        },
        /**
          * Accessible long description
          */
        desc: {
          type: String,
          value: null
        },
        /**
          * An array of data for the donut chart
          */
        options: {
          type: Array,
          computed: '_getOptions(complete,total,size)'
        },
        /**
          * The source of the image in the center of the object.
          */
        imageSrc: {
          type: String,
          value: null,
          reflectToAttribute: true
        },
        /**
          * The alt text for the image.
          */
        imageAlt: {
          type: String,
          value: null,
          reflectToAttribute: true
        },
        /**
          * The style for the image based on the size of the donut
          */
        imageStyle: {
          type: String,
          computed: '_getImageStyle(size)'
        },
        /**
          * The size of the progress-donut: sx, sm, md, lg, or xl. Default is md
          */
        size: {
          type: String,
          value: 'md'
        },
        /**
          * Title
          */
        title: {
          type: String,
        },
        /**
          * An array of incomplete values
          */
        total: {
          type: Number,
          value: 100
        },
      },
      /**
        * Attached to the DOM, now fire.
        */
      attached: function() {
        // Establish hax property binding
        let props = {
          'canScale': true,
          'canPosition': true,
          'canEditSource': false,
          'gizmo': {
            'title': 'Sample gizmo',
            'description': 'The user will be able to see this for selection in a UI.',
            'icon': 'av:play-circle-filled',
            'color': 'grey',
            'groups': ['Video', 'Media'],
            'handles': [
              {
                'type': 'video',
                'url': 'source'
              }
            ],
            'meta': {
              'author': 'Your organization on github'
            }
          },
          'settings': {
            'quick': [
              {
                'property': 'title',
                'title': 'Title',
                'description': 'The title of the element',
                'inputMethod': 'textfield',
                'icon': 'editor:title',
              },
            ],
            'configure': [
              {
                'property': 'title',
                'title': 'Title',
                'description': 'The title of the element',
                'inputMethod': 'textfield',
                'icon': 'editor:title',
              },
            ],
            'advanced': [
            ]
          }
        };
        this.setHaxProperties(props);
      },
      /**
        * Makes chart and returns the chart object. 
        */
       _getData: function(complete){
        return {"series": complete};
      },
      /**
        * Makes chart and returns the chart object. 
        */
       _getImageStyle: function(size){
         let offset = '21%', diameter = '58%';
        if(this.size === 'xs'){
          offset = '29.5%';
          diameter = '41%';
        } else if(this.size === 'sm'){
          offset = '24%';
          diameter = '52%';
        } else if(this.size === 'lg'){
          offset = '19%';
          diameter = '62%';
        } else if(this.size === 'xl'){
          offset = '17%';
          diameter = '66%';
        }
        return 'left: '+offset+'; top: '+offset+'; width: '+diameter+'; height: '+diameter+';';
      },
      /**
        * Makes chart and returns the chart object. 
        */
       _getOptions: function(complete,total,size){
        let sum = 0;
        for(let i=0;i<complete.length;i++){
          sum += parseFloat(complete[i]);
        }
        return {"donut": true, "showLabel":false, "startAngle": 0, "total": Math.max(sum,total)};
      },
      /**
        * Makes chart and returns the chart object. 
        */
      makeChart: function(){
        this.chart = this.$.chart.makeChart();
      },
      /**
        * Makes chart and returns the chart object. 
        */
      _onCreated: function(e){
        let chart = e.detail, strokeWidth = '10%';
        if(this.size === 'xs'){
          strokeWidth = '8%'
        } else if(this.size === 'sm'){
          strokeWidth = '9%'
        } else if(this.size === 'lg'){
          strokeWidth = '11%'
        } else if(this.size === 'xl'){
          strokeWidth = '12%'
        }
        chart.on('draw', function(data) {
          data.element._node.style.strokeWidth = strokeWidth;
          //data.element._node.style.stroke = '#00ff00';
          console.log(data);
          if(data.type === 'slice') {
            // Get the total path length in order to use for dash array animation
            var pathLength = data.element._node.getTotalLength();

            // Set a dasharray that matches the path length as prerequisite to animate dashoffset
            data.element.attr({
              'stroke-dasharray': pathLength + 'px ' + pathLength + 'px'
            });

            // Create animation definition while also assigning an ID to the animation for later sync usage
            var animationDefinition = {
              'stroke-dashoffset': {
                id: 'anim' + data.index,
                dur: 500,
                from: -pathLength + 'px',
                to:  '0px',
                easing: Chartist.Svg.Easing.easeOutQuint,
                // We need to use `fill: 'freeze'` otherwise our animation will fall back to initial (not visible)
                fill: 'freeze'
              }
            };

            // If this was not the first slice, we need to time the animation so that it uses the end sync event of the previous animation
            if(data.index !== 0) {
              animationDefinition['stroke-dashoffset'].begin = 'anim' + (data.index - 1) + '.end';
            }

            // We need to set an initial value before the animation starts as we are not in guided mode which would do that for us
            data.element.attr({
              'stroke-dashoffset': -pathLength + 'px'
            });

            // We can't use guided mode as the animations need to rely on setting begin manually
            // See http://gionkunz.github.io/chartist-js/api-documentation.html#chartistsvg-function-animate
            data.element.animate(animationDefinition, false);
          }
        });
        /*chart.on('created', function() {
          if(window.__anim21278907124) {
            clearTimeout(window.__anim21278907124);
            window.__anim21278907124 = null;
          }
          window.__anim21278907124 = setTimeout(chart.update.bind(chart), 10000);
        });*/
      },
    });
  </script>
</dom-module>
